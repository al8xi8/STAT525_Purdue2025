g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x, N) {
y <- rnorm(N)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x, N) {
# Generate samples from truncated logistic distribution
u <- runif(N)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- w(y_samples, x)
# Importance sampling estimate
mean(weights)
}
# Compute the empirical variances
variances <- matrix(0, 3, 2) # 3 x-values, 2 methods
rownames(variances) <- c("-2", "0", "1")
colnames(variances) <- c("Basic MC", "Importance Sampling")
for (i in 1:3 {
print(variances)
library(stats)
set.seed(117)
# Parameters
N <- 1000
x_values <- c(-2, 0, 1)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x, N) {
y <- rnorm(N)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x, N) {
# Generate samples from truncated logistic distribution
u <- runif(N)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- w(y_samples, x)
# Importance sampling estimate
mean(weights)
}
# Compute the empirical variances
variances <- matrix(0, 3, 2) # 3 x-values, 2 methods
rownames(variances) <- c("-2", "0", "1")
colnames(variances) <- c("Basic MC", "Importance Sampling")
for (i in 1:3) {
x <- x_values[i]
variances[i, 1] <- var(replicate(N, basic_monte_carlo(x, N)))
variances[i, 2] <- var(replicate(N, importance_sampling(x, N)))
}
library(stats)
set.seed(117)
# Parameters
N <- 1000
x_values <- c(-2, 0, 1)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x, N) {
y <- rnorm(N)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x, N) {
# Generate samples from truncated logistic distribution
u <- runif(N)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- w(y, x)
# Importance sampling estimate
mean(weights)
}
# Compute the empirical variances
variances <- matrix(0, 3, 2) # 3 x-values, 2 methods
rownames(variances) <- c("-2", "0", "1")
colnames(variances) <- c("Basic MC", "Importance Sampling")
for (i in 1:3) {
x <- x_values[i]
variances[i, 1] <- var(replicate(N, basic_monte_carlo(x, N)))
variances[i, 2] <- var(replicate(N, importance_sampling(x, N)))
}
print(variances)
#Basic Monte Carlo variance
basic_monte_carlo(x_values[1], N)
#Basic Monte Carlo variance
basic_monte_carlo(x_values[0], N)
#Basic Monte Carlo variance
basic_monte_carlo(x_values[1], N)
#Basic Monte Carlo variance
basic_monte_carlo(x_values[1], N)
#Basic Monte Carlo variances
basic_monte_carlo(-2, N)
#Basic Monte Carlo variances
basic_monte_carlo(-2, 1000)
basic_monte_carlo(0, 1000)
basic_monte_carlo(1, 1000)
for (i in 1:3) {
x <- x_values[i]
variances[i, 1] <- var(replicate(N, basic_monte_carlo(x, N)))
variances[i, 2] <- var(replicate(N, importance_sampling(x, N)))
}
print(variances)
#Calculating the basic Monte Carlo variances
var(basic_monte_carlo(-2, 1000))
#Calculating the basic Monte Carlo variances
var(replicate(1000, basic_monte_carlo(-2, 1000))
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2, 1000)))
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2, 1000))))
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2, 1000))))
print(var(replicate(1000, basic_monte_carlo(-2, 1000))))
print(var(replicate(1000, basic_monte_carlo(0, 1000))))
print(var(replicate(1000, basic_monte_carlo(1, 1000))))
print(var(replicate(1000, importance_sampling(-2, 1000))))
print(var(replicate(1000, importance_sampling(0, 1000))))
print(var(replicate(1000, importance_sampling(1, 1000))))
print(var(replicate(1000, basic_monte_carlo(-2, 1000))))
print(var(replicate(1000, basic_monte_carlo(0, 1000))))
print(var(replicate(1000, basic_monte_carlo(1, 1000))))
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x, 1000) {
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generate samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- w(y, x)
# Importance sampling estimate
mean(weights)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generate samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- w(y, x)
# Importance sampling estimate
mean(weights)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Weight function for importance sampling estimate
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generate samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- (g(y) * F(x) / f(y))
# Importance sampling estimate
mean(weights)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
rm.list(all())
rm(list=ls())
# Required libraries
library(stats)
# Parameters
N <- 1000
x_values <- c(-2, 0, 1)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF and CDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Weight function
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x, N) {
y_samples <- rnorm(N)
indicator <- ifelse(y_samples < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x, N) {
# Generate samples from truncated logistic distribution
u_samples <- runif(N)
y_samples <- -sqrt(3) / pi * log((1 - u_samples * F(x)) / (u_samples * F(x)))
# Compute weights
weights <- w(y_samples, x)
# Importance sampling estimate
mean(weights)
}
# Compute the empirical variances
variances <- matrix(0, 3, 2) # 3 x-values, 2 methods
rownames(variances) <- c("-2", "0", "1")
colnames(variances) <- c("Basic MC", "Importance Sampling")
for (i in 1:length(x_values)) {
x <- x_values[i]
variances[i, 1] <- var(replicate(N, basic_monte_carlo(x, N)))
variances[i, 2] <- var(replicate(N, importance_sampling(x, N)))
}
print(variances)
rm(list=ls())
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Weight function for importance sampling estimate
w <- function(y, x) {
g(y) * F(x) / f(y)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generate samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
# Compute weights
weights <- (g(y) * F(x) / f(y))
# Importance sampling estimate
mean(weights)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
rm(list=ls())
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generates samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
#Computes importance sampling weight
weight <- (g(y) * F(x) / f(y))
#Our final estimate
mean(weights)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
rm(list=ls())
library(stats)
set.seed(117)
# Standard Normal PDF
g <- function(y) {
dnorm(y)
}
# Logistic PDF
f <- function(y) {
exp(-pi * y / sqrt(3)) / (1 + exp(-pi * y / sqrt(3)))^2
}
# Logistic CDF
F <- function(x) {
1 / (1 + exp(-pi * x / sqrt(3)))
}
# Basic Monte Carlo estimate
basic_monte_carlo <- function(x) {
y <- rnorm(1000)
indicator <- ifelse(y < x, 1, 0)
mean(indicator)
}
# Importance Sampling estimate
importance_sampling <- function(x) {
# Generates samples from truncated logistic distribution
u <- runif(1000)
#This is the value of y we calculated using inverse transform sampling in B2.
y <- -sqrt(3) / pi * log((1 - u * F(x)) / (u * F(x)))
#Computes importance sampling weight
weight <- (g(y) * F(x) / f(y))
#Our final estimate
mean(weight)
}
#Calculating the basic Monte Carlo variances
print(var(replicate(1000, basic_monte_carlo(-2))))
print(var(replicate(1000, basic_monte_carlo(0))))
print(var(replicate(1000, basic_monte_carlo(1))))
#Calculating the Importance Sampling variances
print(var(replicate(1000, importance_sampling(-2))))
print(var(replicate(1000, importance_sampling(0))))
print(var(replicate(1000, importance_sampling(1))))
alpha <- 0.5
numerator_df <- 4
denominator_df <- 27
critical_f <- qf(1 - alpha, numerator_df, denominator_df)
print(paste("Critical F-value is:", critical_f))
alpha <- 0.5
numerator_df <- 2
denominator_df <- 27
critical_f <- qf(1 - alpha, numerator_df, denominator_df)
print(paste("Critical F-value is:", critical_f))
t(0.9722,324)
t(0.9722, 324)
qt(0.9722,324)
denominator_df <- 324
alpha <- 0.5
numerator_df <- 5
denominator_df <- 324
critical_f <- qf(1 - alpha, numerator_df, denominator_df)
print(paste("Critical F-value is:", critical_f))
alpha <- 0.5
numerator_df <- 10
denominator_df <- 324
critical_f <- qf(1 - alpha, numerator_df, denominator_df)
print(paste("Critical F-value is:", critical_f))
qf(6.740246933518981e-10, 6, 81)
qf(12.4615, 6, 81)
qf(6.740246933518981e-10, 81, 6)
qf(6.740246933518981e-10, 6, 81)
qf(1 - 6.740246933518981e-10, 6, 81)
pf(12.46154, 6, 81)
pf(12.46154, 6, 81, lower.tail = FALSE)
pf(12.4615, 6, 81, lower.tail = FALSE)
